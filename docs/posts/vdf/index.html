<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.340">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Trevor Tomlin">
<meta name="dcterms.date" content="2023-07-11">

<title>Trevor’s Website - Verifiable Delay Functions</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Trevor’s Website</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/trevortomlin" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/trevor-tomlin/" rel="" target=""><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Verifiable Delay Functions</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">cryptography</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Trevor Tomlin </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">July 11, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    </div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">




<section id="verifiable-delay-functions" class="level1 page-columns page-full">
<h1>Verifiable Delay Functions</h1>
<p>A <strong>Verifiable Delay Function</strong> (VDF) is a computational primitive that introduces a time delay in evaluating a function while providing proof of its correctness. In simple terms, it is a function that takes an input and produces an output after a specific time period, making it computationally expensive to compute the output faster. The key property of VDFs is that they are easy to verify once the output is obtained, but computationally challenging to compute within a shorter time frame. In this blog post, we will delve into the world of VDFs, exploring their applications, properties, and potential impact on the field of cryptography.</p>
<section id="definition-of-vdf" class="level2">
<h2 class="anchored" data-anchor-id="definition-of-vdf">Definition of VDF</h2>
<ol type="1">
<li><strong>Verifiable</strong>: The output of the function can be verified to be correct.</li>
<li><strong>Delay</strong>: The output of the function cannot be computed faster than a specific time period and runs sequentially.</li>
<li><strong>Function</strong>: The function is deterministic and has a unique output for each input.</li>
</ol>
</section>
<section id="naive-vdf" class="level2">
<h2 class="anchored" data-anchor-id="naive-vdf">Naive VDF</h2>
<p>We can hash a value <span class="math inline">\(t\)</span> times to create a naive VDF.</p>
<p><span class="math inline">\(H^t(x) = H(H(...H(x)))\)</span></p>
<p>We then use a SNARK to prove that the output is correct. Alternatively, we could recompute the hashes, however, that would be infeasable.</p>
<p>This method <em>works</em> because it is sequential and verifiable, but there are far more efficient methods available.</p>
</section>
<section id="pietrzaks-vdf" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="pietrzaks-vdf">Pietrzak’s VDF</h2>
<p>Pietrzak’s VDF found a solution using groups of unknown order. Here’s how it works:</p>

<div class="no-row-height column-margin column-container"><div class="">
<p><strong>What is a group of unknown order?</strong> A group of unknown order is a group where the parties do not know how many elements are in the group. For instance, in RSA groups, we generate two prime numbers <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> and multiply them together to get the composite modulus <span class="math inline">\(n\)</span>. If we know the order of the group, we can solve the problem much easier. To create the order <span class="math inline">\(n\)</span> we have to use a trusted setup by relying on something like multi-party computation.</p>
</div></div><ol type="1">
<li>We establish a VDF with t steps, a hash function H that maps bytes <span class="math inline">\(\rightarrow\)</span> elements of <span class="math inline">\(G\)</span>, and a finite abelian group of unknown order <span class="math inline">\(G\)</span>.</li>
<li>We compute the VDF as <span class="math inline">\(y = {H(x)^{2}}^{t}\)</span></li>
</ol>
<p>The squaring of the hash function is what makes this VDF sequential and the fact that <span class="math inline">\(G\)</span> is a group of unknown order makes it difficult to compute the output faster than <span class="math inline">\(t\)</span> steps.</p>
<p>For the proof, the verifier wants to prove <span class="math inline">\(y = {H(x)^2}^{t}\)</span> so they first sends <span class="math inline">\(\mu = {H(x)^2}^{\frac{t}{2}}\)</span>. Then the verifier will send a random value r which is constrained to be less than the security parameter <span class="math inline">\(\lambda\)</span> (which was chosen during initialization). Then both parties compute <span class="math inline">\(x_1 = x^r * \mu\)</span> and <span class="math inline">\(y = \mu^r * y\)</span>. If the original statement was correct, then <span class="math inline">\(y_1 = {x_1^2}^{\frac{t}{2}}\)</span>. This is repeated <span class="math inline">\(\log_2(t)\)</span> times until <span class="math inline">\(t=1\)</span> to get the final proof.</p>
<p>This can be made into a non-interactive proof by using the Fiat-Shamir transformation.</p>
</section>
<section id="wesolowskis-vdf" class="level2">
<h2 class="anchored" data-anchor-id="wesolowskis-vdf">Wesolowski’s VDF</h2>
<p>Wesolowski’s VDF is similar to Pietrzaks except for the verification step. Instead of halving recursively, the prover gives a point near the end of the sequence and the verifier computers the rest of the sequence to verify the output. The prover only has to store a single point and the the prime number which is a lot less space than Pietrzak’s VDF.</p>
</section>
<section id="finite-groups-of-unknown-order" class="level2">
<h2 class="anchored" data-anchor-id="finite-groups-of-unknown-order">Finite Groups of Unknown Order</h2>
<section id="rsa" class="level3">
<h3 class="anchored" data-anchor-id="rsa">RSA</h3>
<p>As mentioned above, the most popular option for VDFs is using RSA groups. These groups have been studied extensively and it is known how to create them securely. The downside is that they require a trusted setup to generate the order of the group which could compromise security if the setup is not done correctly.</p>
</section>
<section id="class-groups" class="level3">
<h3 class="anchored" data-anchor-id="class-groups">Class Groups</h3>
<p>Class Groups are a newer area of research that aim to eliminate the trusted setup requirement of RSA groups. One downside of class groups is that their operations are more computationally expensive than RSA groups. However, the fact that they can switch groups often because they do not require a trusted setup makes them a good candidate for VDFs. More research needs to be done on these groups, but they appear to be a promising option.</p>
</section>
</section>
<section id="applications" class="level2">
<h2 class="anchored" data-anchor-id="applications">Applications</h2>
<p>One big application of VDFs are randomness beacons. Imagine that there is an lottery on a blockchain and the lottery takes some amount of randomness from the a certain blocks hash to generate the numbers. One visible flaw to this method is that miners could withhold blocks until they find a block that gives them the numbers they want. This is called a <em>block withholding attack</em>. To prevent this, we can use a VDF to generate the randomness. The VDF would take the hash of the block as input and output a random number after a certain amount of time passed. The VDF would be sequential so miners would not be able to withhold blocks to find the right hash. The VDF would also be verifiable so that the miners could not lie about the output. This would prevent block withholding attacks and make the lottery more secure.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>In conclusion, Verifiable Delay Functions (VDFs) provide a powerful cryptographic tool for achieving time-delayed computations with verifiability. By utilizing sequential and non-parallelizable operations, VDFs introduce a time delay that enhances security and prevents manipulation. The applications of VDFs are vast, with randomness beacons being a notable use case. VDF-based randomness beacons ensure the generation of unbiased and publicly verifiable random numbers, thereby enhancing the fairness and integrity of applications such as lotteries and cryptographic protocols. Ongoing research and development in VDFs aim to improve efficiency, explore new constructions, and expand their applications, making VDFs a promising area in the field of cryptography with significant potential for enhancing security and trust in various domains.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>