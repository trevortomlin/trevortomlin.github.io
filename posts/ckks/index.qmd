---
title: "Introduction to CKKS"
author: "Trevor Tomlin"
date: "2023-09-14"
categories: [cryptography]
---

# An introduction to the **HEAAN / CKKS** homomorphic encryption scheme
The **HEAAN / CKKS** scheme introduced in the paper, *Homomorphic Encryption
for Arithmetic of Approximate Numbers* or named after the authors, Jung Hee Cheon, Andrey Kim, Miran Kim, and Yongsoo Song is a leveled
homomorphic scheme based upon the Ring Learning with Errors (RLWE) problem that allows encypted computation on real real numbers. This scheme differs from
BGV/BFV schemes because it works on real numbers rather than integers.

## Notation
Understanding the following notations will be helpful for reading this blog post:

* $\mathcal{R} = \mathbb{Z}[X]/(X^N +1)$
* $\mathbb{Z}_q$ is in the range $(−q/2, q/2]$
* $\lfloor x \rceil$ represents the rounding of the real number x to the closest integer

## Encoding 
This scheme operates allows us to encode a vector, $\mathbb{C}^{N/2}$, into the ciphertext space, $\mathcal{R}_q = (\mathbb{Z}/q\mathbb{Z})[X]/(X^N +1)$ 
using a ring isomorphism and cannoncial embedding map. 

A cyclotomic polynomial is a polynomial with integer coefficients whose roots are all
primitive. An example would be the 4th cyclotomic polynomial or $\phi_4(x) = x^2 + 1$.
One important property of cyclotomic polynomials is that if N is a power of two, then
the polynomial is equal to $x^{N/2} + 1$. More information about these polynomials can be 
found here on [Wikipedia](https://en.wikipedia.org/wiki/Cyclotomic_polynomial)

For any cyclotomic polynomial, $a$, we can say that $m(\xi^j) = m(\overline{\xi^{-j}})$ 


```{python}
#| code-fold: true

import numpy as np
import math

def primitive_nth_roots_of_unity(n: int) -> np.ndarray:
    roots = []
    
    for i in range(1, n+1):
        if math.gcd(i, n) == 1:
            root = np.e ** (2 * np.pi * 1j * i / n)
            roots.append(root)

    return np.array(roots)

#print()
eigth_prim_roots = primitive_nth_roots_of_unity(8)

for i, r in enumerate(eigth_prim_roots):
    print(f"Root #{i+1}: {r}\nConjugate: {np.conjugate(r)}\n")

```

From this week can see that $\xi^1 = \overline{\xi^7}$ and $\xi^3 = \overline{\xi^5}$.

```{python}
#| code-fold: true

import numpy as np
import matplotlib.pyplot as plt

# Number of primitive roots of unity
n = 8

# Calculate the primitive 8th roots of unity
roots = [np.exp(2j * np.pi * k / n) for k in range(n) if np.gcd(k, n) == 1]

# Separate real and imaginary parts
real_parts = [root.real for root in roots]
imaginary_parts = [root.imag for root in roots]

# Define labels for the roots
labels = ['ξ^1', 'ξ^3', 'ξ^5', 'ξ^7']

# Create a scatter plot with labels
for i, (x, y) in enumerate(zip(real_parts, imaginary_parts)):
    plt.scatter(x, y, color='red', label=labels[i])
    plt.text(x + 0.1, y, labels[i], fontsize=12)

# Add lines from the origin to each point
for root in roots:
    plt.plot([0, root.real], [0, root.imag], linestyle='--', color='blue')

# Add labels and a legend
plt.xlabel('Real Part')
plt.ylabel('Imaginary Part')
plt.axhline(0, color='black', linewidth=0.5)
plt.axvline(0, color='black', linewidth=0.5)
plt.grid(color='gray', linestyle='--', linewidth=0.5)
plt.legend()

# Set the aspect ratio to be equal
plt.axis('equal')

# Set plot limits
plt.xlim(-1.5, 1.5)
plt.ylim(-1.5, 1.5)

# Title
plt.title(f'Primitive 8th Roots of Unity with Labels')

# Show the plot
plt.show()
```

This makes intuitive sense if we look at a graph of the roots and see that primitive roots of unity are always symmetric over the x axis.

The subring $\mathbb{H}$ of $\mathbb{C}^N$ is defined as


$\sigma(x)$ is equivalent to the evaluation of a polynomial on the roots of unity
for the given cyclotomic polynomial which will produce an element in $\mathbb{C}^N$. 

1. We define an operation $\pi^{-1}$ which 

## Decoding

## Encryption

## Decryption

## Addition of Constants

## Addition of Ciphertexts

## Multiplication of Constants

## Multiplication of Ciphertexts

## Next Steps

## Resources