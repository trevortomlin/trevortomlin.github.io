---
title: "Introduction to CKKS"
author: "Trevor Tomlin"
date: "2023-09-14"
categories: [cryptography]
---

# An introduction to the **HEAAN / CKKS** homomorphic encryption scheme
The **HEAAN / CKKS** scheme introduced in the paper, *Homomorphic Encryption
for Arithmetic of Approximate Numbers* or named after the authors, Jung Hee Cheon, Andrey Kim, Miran Kim, and Yongsoo Song is a leveled
homomorphic scheme based upon the Ring Learning with Errors (RLWE) problem that allows encypted computation on real real numbers. This scheme differs from
BGV/BFV schemes because it works on real numbers rather than integers.

## Notation
Understanding the following notations will be helpful for reading this blog post:

* $\mathcal{R} = \mathbb{Z}[X]/(X^N +1)$
* $\mathbb{Z}_q$ is in the range $(−q/2, q/2]$
* $\lfloor x \rceil$ represents the rounding of the real number x to the closest integer

## Parameters

$\Delta$ is the scaling factor

## Encoding 
This scheme operates allows us to encode a vector, $\mathbb{C}^{N/2}$, into the ciphertext space, $\mathcal{R}_q = (\mathbb{Z}/q\mathbb{Z})[X]/(X^N +1)$ 
using a ring isomorphism and cannoncial embedding map. 

A cyclotomic polynomial is a polynomial with integer coefficients whose roots are all
primitive. An example would be the 4th cyclotomic polynomial or $\phi_4(x) = x^2 + 1$.
One important property of cyclotomic polynomials is that if N is a power of two, then
the polynomial is equal to $x^{N/2} + 1$. 

<!-- ADD MORE ABOUT WHY POWERS OF 2 ARE GOOD -->
[A Toolkit for Ring-LWE Cryptography](https://web.eecs.umich.edu/~cpeikert/pubs/toolkit.pdf)

More information about these polynomials can be 
found here on [Wikipedia](https://en.wikipedia.org/wiki/Cyclotomic_polynomial)

For any cyclotomic polynomial, $a$, we can say that $a(\xi^j) = a(\overline{\xi^{-j}})$ 


```{python}
#| code-fold: true

import numpy as np
import math

def primitive_nth_roots_of_unity(n: int) -> np.ndarray:
    roots = []
    
    for i in range(1, n+1):
        if math.gcd(i, n) == 1:
            root = np.e ** (2 * np.pi * 1j * i / n)
            roots.append(root)

    return np.array(roots)

eigth_prim_roots = primitive_nth_roots_of_unity(8)

for i, r in enumerate(eigth_prim_roots):
    print(f"Root #{i+1}: {r}\nConjugate: {np.conjugate(r)}\n")

```

From this week can see that $\xi^1 = \overline{\xi^7}$ and $\xi^3 = \overline{\xi^5}$.

```{python}
#| code-fold: true

import numpy as np
import matplotlib.pyplot as plt

n = 8

roots = [np.exp(2j * np.pi * k / n) for k in range(n) if np.gcd(k, n) == 1]

real_parts = [root.real for root in roots]
imaginary_parts = [root.imag for root in roots]

labels = ['ξ^1', 'ξ^3', 'ξ^5', 'ξ^7']

for i, (x, y) in enumerate(zip(real_parts, imaginary_parts)):
    plt.scatter(x, y, color='red', label=labels[i])
    plt.text(x + 0.1, y, labels[i], fontsize=12)

for root in roots:
    plt.plot([0, root.real], [0, root.imag], linestyle='--', color='blue')

plt.xlabel('Real Part')
plt.ylabel('Imaginary Part')
plt.axhline(0, color='black', linewidth=0.5)
plt.axvline(0, color='black', linewidth=0.5)
plt.grid(color='gray', linestyle='--', linewidth=0.5)

plt.axis('equal')

plt.xlim(-1.5, 1.5)
plt.ylim(-1.5, 1.5)

plt.title(f'Primitive 8th Roots of Unity')

plt.show()
```

This makes intuitive sense if we look at a graph of the roots and see that primitive roots of unity are always symmetric over the x axis.

$\mathbb{H}$ of is a subring of $\mathbb{C}^N$ that contains elements of $\mathbb{C}^N$ where the conjugate is also in the subring.

We define an operation $\pi^{-1}$ which expands a vector $\mathbb{C}^{N/2}$ into $\mathbb{H}$

```{python}
def pi_inverse(z: np.ndarray) -> np.ndarray:
    return np.concatenate([z, [np.conjugate(x) for x in z[::-1]]])

z = np.array([3+4j,2-1j])

for i in range(len(z)):
    print(f"i: {i}, {z[i]} = i: {(-i-1) % 4}, {np.conjugate(z[-i])}")

print()
print(list(pi_inverse(z)))
```

$\sigma(x)$ is equivalent to the evaluation of a polynomial on the roots of unity
for the given cyclotomic polynomial which will produce an element in $\mathbb{C}^N$. 

Imagine $\Delta$ is 10,000. We can say that $\frac{(\Delta m * \Delta n)}{\Delta^2} =  m * n$. 
For example let $m = 3.14$ and $n = 2.72$. We expect the result to equal 8.5408.

1. Multiply $m$ by $\Delta$, $\Delta * m = 31,400$
2. Multiply $n$ by $\Delta$, $\Delta * n = 27,200$
3. Add $\Delta m * \Delta n = 854,080,000$
4. Divide result by $\Delta^2$, $854,080,000 / \Delta^2 = 8.5408$

The canonical embedding $\sigma$ is defined as $\sigma : \mathbb{R}[X]/(X^N +1) \rightarrow \mathbb{C}^N$ which is equaluating the polynomial on
the primitive complex roots of unity to get a vector of points
Its inverse would be $\sigma^{-1} : \mathbb{C}^N \rightarrow \mathbb{R}[X]/(X^N +1)$ which takes a list of points and produces a polynomial.

An element in $\mathbb{H}$ is not necessarily an element in $\sigma(\mathcal{R})$ so we have to project each element into $\sigma(\mathcal{R})$.

We want to project the elements of $\mathbb{H}$ onto the bases of $\sigma(\mathcal{R})$ which are $\beta = (\sigma(1),\sigma(X),\dots,\sigma(X^{N−1}))$ and to have integer coefficients rather than complex ones.

A technique for this discretization is called "coordinate-wise randomized rounding" and is explained in section 2.4.2 of [A Toolkit for Ring-LWE Cryptography](https://web.eecs.umich.edu/~cpeikert/pubs/toolkit.pdf).

The first step is to project the elements of our vector $z$ onto the bases of $\sigma(\mathcal{R})$.

This can be done by using the vector projection equation first learning in a college algebra course.
It is defined as $proj_\beta z = \frac{z * \beta}{\left\| \beta \right\|} * \beta$.

After that we will have a polynomial that has the same bases of $\sigma(\mathcal{R})$, but we still need to round it so that it has integer coefficients.





## Decoding

## Encryption

## Decryption

## Addition of Constants

## Addition of Ciphertexts

## Multiplication of Constants

## Multiplication of Ciphertexts

## Next Steps

## References