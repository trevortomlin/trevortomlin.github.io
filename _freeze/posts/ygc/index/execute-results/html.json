{
  "hash": "8b82d8efd5a5d80fef79f361513406c2",
  "result": {
    "markdown": "---\ntitle: \"Yao's Garbled Circuits\"\nauthor: \"Trevor Tomlin\"\ndate: \"2023-06-28\"\ncategories: [cryptography]\n---\n\n# Introduction to Yao's Garbled Circuits\nYao's Garbled Circuits is a cryptographic protocol introduced by Andrew Yao in 1982 that enables secure two-party computation. It allows two parties, let's call them Alice and Bob, to compute a function on their private inputs without revealing their inputs to each other. In this blog post, we'll explore the concept of Yao's Garbled Circuits and provide Python code examples to demonstrate its implementation.\n\n## How it works\nYao's Garbled Circuits is a form of MPC where there are only two parties and each party is assumed to be \"honest-but-curious\" meaning that they might try and look at things they shouldn't, but they won't actively try and break the protocol. The participants are trying to compute the function $f(x, y)$ which is a boolean circuit meaning that all inputs are 0 or 1 and there are nodes like AND, OR, and NOT gates that connect inputs. The function is known to both parties, but they don't want to reveal their inputs to each other. The protocol works as follows:\n\n1. Alice and Bob agree on a boolean circuit $f(x)$ that they want to compute\n2. Alice garbles the circuit and sends it along with her encrypted input $x0$ to Bob\n3. Bob encrypts his input $x1$ by using an Oblivious Transfer protocol with Alice\n4. Bob evaluates the garbled circuit with his encrypted input and sends the result to Alice\n\nLets go through each of these steps in more detail.\n\nIn this example we are going to compute the function $f(x, y) = x \\oplus y$ where $\\oplus$ is the XOR operator. Alice has input $x = 1$ and Bob has input $y = 0$. The first step is to agree on a boolean circuit that computes $f(x, y)$.\n\n![](diagram1.png){width=\"40%\"}\n\nThen Alice will generate a key for each wire and each possible value for the wire. In this case there are two wires and each wire can be 0 or 1 so there are four keys. \n![](diagram2.png){width=\"40%\"}\n\nAlice encrypts each output value with the corresponding keys and permutes the table randomly. Then she sends the garbled circuit to Bob along with her encrypted input $x0$.\n![](diagram3.png)\n\nBob uses an [Oblivious Transfer protocol](https://www.trevortomlin.com/posts/ot/) to select which key he wants from alice.\n![](diagram4.png)\n\nSince Bob now has Alice's key and the key for his own input, he can decrypt the output value and send it to Alice. Bob either has to go through every entry in the table and try to see if it decrypts, or there can be a select bit specified in the protocol so he knows where to look. Bob then sends the output value to Alice.\n\n## Multi Gate Circuits\nFor multi gate circuits instead of calculating the encryption directly on the function output, the garbler will also generate a key for the output and encrypt that key instead. Then when Bob decrypts the circuit, he will get the output key which can be fed into other circuits.\n\n## Example Code\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport os\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad, unpad\n\n# store the xor table in a dictionary\nxor_table = {\n    (0, 0): 0,\n    (0, 1): 1,\n    (1, 0): 1,\n    (1, 1): 0\n}\n\n# generate keys for each wire and each possible value\ndef generate_keys():\n    keys = {}\n    for wire in range(2):\n        for value in range(2):\n            keys[(wire, value)] = os.urandom(16)\n    return keys\n\n# encrypt the output value with the corresponding keys\ndef encrypt_output(keys):\n    encrypted_output = {}\n    for (wire, value), key in keys.items():\n        encrypted_output[(wire, value)] = AES.new(key, AES.MODE_ECB).encrypt(pad(str(xor_table[(wire, value)]).encode(), 16))\n    print(encrypted_output)\n    return encrypted_output\n\n# permute the table randomly\ndef permute_table(encrypted_output):\n    return encrypted_output\n\n# garble the circuit\ndef garble_circuit():\n    keys = generate_keys()\n    encrypted_output = encrypt_output(keys)\n    permuted_table = permute_table(encrypted_output)\n    return permuted_table, keys\n\n# evaluate the circuit\ndef evaluate_circuit(permuted_table, x0, x1):\n    output = None\n    for (wire, value), encrypted_output in permuted_table.items():\n        if wire == 0:\n            if value == x0:\n                output = encrypted_output\n        elif wire == 1:\n            if value == x1:\n                output = encrypted_output\n    return output\n\nprint(\"XOR Table\")\nprint(\"x0\\tx1\\tf(x0, x1)\")\nfor x0 in range(2):\n    for x1 in range(2):\n        print(f\"{x0}\\t{x1}\\t{xor_table[(x0, x1)]}\")\n\nprint(\"-\" * 20)\n\n# Alice garbles the circuit and sends it to Bob\npermuted_table, keys = garble_circuit()\n\nprint(\"Garbled Table\")\nprint(\"x0\\tx1\")\nfor (wire, value), encrypted_output in permuted_table.items():\n    print(f\"{wire}\\t{value}\")\n\nprint(keys)\n\nx0 = 0\n\n# Bob evaluates the circuit\nx1 = 1\n\noutput = evaluate_circuit(permuted_table, x0, x1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nXOR Table\nx0\tx1\tf(x0, x1)\n0\t0\t0\n0\t1\t1\n1\t0\t1\n1\t1\t0\n--------------------\n{(0, 0): b'&@d7\\xe7=\\xca\\xca\\x7f3\\xdb\\xbd\\x10\\x1a\\x14#', (0, 1): b'\\xaeN\\x90\\x05\\xe0G\\xf9D\\xe0N0\\x83m\\xcdQj', (1, 0): b'?Hig\\x1d:g\\xe4\\x00\\x95JS\\xc0\\x89\\xd1\\x8a', (1, 1): b\"\\xc7R\\x13'\\xf8?\\xbf\\xad\\xa5\\x9c(w\\x19\\xba\\x17\\xd1\"}\nGarbled Table\nx0\tx1\n0\t0\n0\t1\n1\t0\n1\t1\n{(0, 0): b'\\xf9\\x01lE\\xe5a\\xb7n\\xdeM\\xe3\\xdag\\x7f\\x80\\xc8', (0, 1): b'h\\x06\\xcb3\\xfa\\xd2\\xd7K\\xfa\\x96\\x01\\xc3\\xc4*?\\xcf', (1, 0): b'\\xfaO\\x88\\xe2\\x94O(\\xef\\x0bA\\xd6K\\xab`_F', (1, 1): b'vS\\xb2q-\\xe2\\xeb\\xb9-W\\xc0( d\\xf2\\xdb'}\n```\n:::\n:::\n\n\n## Applications\n\n## Conclusion\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}