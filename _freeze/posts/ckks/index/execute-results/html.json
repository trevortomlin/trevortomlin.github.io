{
  "hash": "f30ab7ffcbecbfb1783db4516bac44ce",
  "result": {
    "markdown": "---\ntitle: \"Introduction to CKKS\"\nauthor: \"Trevor Tomlin\"\ndate: \"2023-09-14\"\ncategories: [cryptography]\n---\n\n# An introduction to the **HEAAN / CKKS** homomorphic encryption scheme\nThe **HEAAN / CKKS** scheme introduced in the paper, *Homomorphic Encryption\nfor Arithmetic of Approximate Numbers* or named after the authors, Jung Hee Cheon, Andrey Kim, Miran Kim, and Yongsoo Song is a leveled\nhomomorphic scheme based upon the Ring Learning with Errors (RLWE) problem that allows encypted computation on real real numbers. This scheme differs from\nBGV/BFV schemes because it works on real numbers rather than integers.\n\n## Notation\nUnderstanding the following notations will be helpful for reading this blog post:\n\n* $\\mathcal{R} = \\mathbb{Z}[X]/(X^N +1)$\n* $\\mathbb{Z}_q$ is in the range $(âˆ’q/2, q/2]$\n* $\\lfloor x \\rceil$ represents the rounding of the real number x to the closest integer\n\n## Encoding \nThis scheme operates allows us to encode a vector, $\\mathbb{C}^{N/2}$, into the ciphertext space, $\\mathcal{R}_q = (\\mathbb{Z}/q\\mathbb{Z})[X]/(X^N +1)$ \nusing a ring isomorphism and cannoncial embedding map. \n\nA cyclotomic polynomial is a polynomial with integer coefficients whose roots are all\nprimitive. An example would be the 4th cyclotomic polynomial or $\\phi_4(x) = x^2 + 1$.\nOne important property of cyclotomic polynomials is that if N is a power of two, then\nthe polynomial is equal to $x^{N/2} + 1$. More information about these polynomials can be \nfound here on [Wikipedia](https://en.wikipedia.org/wiki/Cyclotomic_polynomial)\n\nFor any cyclotomic polynomial, $a$, we can say that $m(\\xi^j) = m(\\overline{\\xi^{-j}})$ \n\n::: {.cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport math\n\ndef primitive_nth_roots_of_unity(n: int) -> np.ndarray:\n    roots = []\n    \n    for i in range(1, n+1):\n        if math.gcd(i, n) == 1:\n            root = np.e ** (2 * np.pi * 1j * i / n)\n            roots.append(root)\n\n    return np.array(roots)\n\n#print()\neigth_prim_roots = primitive_nth_roots_of_unity(8)\n\nfor i, r in enumerate(eigth_prim_roots):\n    print(f\"Root #{i+1}: {r}\\nConjugate: {np.conjugate(r)}\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRoot #1: (0.7071067811865476+0.7071067811865475j)\nConjugate: (0.7071067811865476-0.7071067811865475j)\n\nRoot #2: (-0.7071067811865475+0.7071067811865476j)\nConjugate: (-0.7071067811865475-0.7071067811865476j)\n\nRoot #3: (-0.7071067811865477-0.7071067811865475j)\nConjugate: (-0.7071067811865477+0.7071067811865475j)\n\nRoot #4: (0.7071067811865474-0.7071067811865477j)\nConjugate: (0.7071067811865474+0.7071067811865477j)\n\n```\n:::\n:::\n\n\nFrom this week can see that $\\xi^1 = \\overline{\\xi^7}$ and $\\xi^3 = \\overline{\\xi^5}$.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Number of primitive roots of unity\nn = 8\n\n# Calculate the primitive 8th roots of unity\nroots = [np.exp(2j * np.pi * k / n) for k in range(n) if np.gcd(k, n) == 1]\n\n# Separate real and imaginary parts\nreal_parts = [root.real for root in roots]\nimaginary_parts = [root.imag for root in roots]\n\n# Define labels for the roots\nlabels = ['xi 1', 'xi 3', 'xi 5', 'xi 7']\n\n# Create a scatter plot with labels\nfor i, (x, y) in enumerate(zip(real_parts, imaginary_parts)):\n    plt.scatter(x, y, color='red', label=labels[i])\n    plt.text(x + 0.1, y, labels[i], fontsize=12)\n\n# Add lines from the origin to each point\nfor root in roots:\n    plt.plot([0, root.real], [0, root.imag], linestyle='--', color='blue')\n\n# Add labels and a legend\nplt.xlabel('Real Part')\nplt.ylabel('Imaginary Part')\nplt.axhline(0, color='black', linewidth=0.5)\nplt.axvline(0, color='black', linewidth=0.5)\nplt.grid(color='gray', linestyle='--', linewidth=0.5)\nplt.legend()\n\n# Set the aspect ratio to be equal\nplt.axis('equal')\n\n# Set plot limits\nplt.xlim(-1.5, 1.5)\nplt.ylim(-1.5, 1.5)\n\n# Title\nplt.title(f'Primitive 8th Roots of Unity with Labels')\n\n# Show the plot\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-3-output-1.png){width=619 height=449}\n:::\n:::\n\n\nThis makes intuitive sense if we look at a graph of the roots and see that primitive roots of unity are always symmetric over the x axis.\n\nThe subring $\\mathbb{H}$ of $\\mathbb{C}^N$ is defined as\n\n\n$\\sigma(x)$ is equivalent to the evaluation of a polynomial on the roots of unity\nfor the given cyclotomic polynomial which will produce an element in $\\mathbb{C}^N$. \n\n1. We define an operation $\\pi^{-1}$ which \n\n## Decoding\n\n## Encryption\n\n## Decryption\n\n## Addition of Constants\n\n## Addition of Ciphertexts\n\n## Multiplication of Constants\n\n## Multiplication of Ciphertexts\n\n## Next Steps\n\n## Resources\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}