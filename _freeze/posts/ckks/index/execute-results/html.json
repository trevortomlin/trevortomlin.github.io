{
  "hash": "d4bc723917758aa606685be3a30051a1",
  "result": {
    "markdown": "---\ntitle: \"Introduction to CKKS\"\nauthor: \"Trevor Tomlin\"\ndate: \"2023-09-14\"\ncategories: [cryptography]\n---\n\n# An introduction to the **HEAAN / CKKS** homomorphic encryption scheme\nThe **HEAAN / CKKS** scheme introduced in the paper, *Homomorphic Encryption\nfor Arithmetic of Approximate Numbers* or named after the authors, Jung Hee Cheon, Andrey Kim, Miran Kim, and Yongsoo Song is a leveled\nhomomorphic scheme based upon the Ring Learning with Errors (RLWE) problem that allows encypted computation on real real numbers. This scheme differs from\nBGV/BFV schemes because it works on real numbers rather than integers.\n\n## Notation\nUnderstanding the following notations will be helpful for reading this blog post:\n\n* $\\mathcal{R} = \\mathbb{Z}[X]/(X^N +1)$\n* $\\mathbb{Z}_q$ is in the range $(−q/2, q/2]$\n* $\\lfloor x \\rceil$ represents the rounding of the real number x to the closest integer\n\n## Parameters\n\n$\\Delta$ is the scaling factor\n\n## Encoding \nThis scheme operates allows us to encode a vector, $\\mathbb{C}^{N/2}$, into the ciphertext space, $\\mathcal{R}_q = (\\mathbb{Z}/q\\mathbb{Z})[X]/(X^N +1)$ \nusing a ring isomorphism and cannoncial embedding map. \n\nA cyclotomic polynomial is a polynomial with integer coefficients whose roots are all\nprimitive. An example would be the 4th cyclotomic polynomial or $\\phi_4(x) = x^2 + 1$.\nOne important property of cyclotomic polynomials is that if N is a power of two, then\nthe polynomial is equal to $x^{N/2} + 1$. \n\n<!-- ADD MORE ABOUT WHY POWERS OF 2 ARE GOOD -->\n[A Toolkit for Ring-LWE Cryptography](https://web.eecs.umich.edu/~cpeikert/pubs/toolkit.pdf)\n\nMore information about these polynomials can be \nfound here on [Wikipedia](https://en.wikipedia.org/wiki/Cyclotomic_polynomial)\n\nFor any cyclotomic polynomial, $a$, we can say that $a(\\xi^j) = a(\\overline{\\xi^{-j}})$ \n\n::: {.cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport math\n\ndef primitive_nth_roots_of_unity(n: int) -> np.ndarray:\n    roots = []\n    \n    for i in range(1, n+1):\n        if math.gcd(i, n) == 1:\n            root = np.e ** (2 * np.pi * 1j * i / n)\n            roots.append(root)\n\n    return np.array(roots)\n\neigth_prim_roots = primitive_nth_roots_of_unity(8)\n\nfor i, r in enumerate(eigth_prim_roots):\n    print(f\"Root #{i+1}: {r}\\nConjugate: {np.conjugate(r)}\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRoot #1: (0.7071067811865476+0.7071067811865475j)\nConjugate: (0.7071067811865476-0.7071067811865475j)\n\nRoot #2: (-0.7071067811865475+0.7071067811865476j)\nConjugate: (-0.7071067811865475-0.7071067811865476j)\n\nRoot #3: (-0.7071067811865477-0.7071067811865475j)\nConjugate: (-0.7071067811865477+0.7071067811865475j)\n\nRoot #4: (0.7071067811865474-0.7071067811865477j)\nConjugate: (0.7071067811865474+0.7071067811865477j)\n\n```\n:::\n:::\n\n\nFrom this week can see that $\\xi^1 = \\overline{\\xi^7}$ and $\\xi^3 = \\overline{\\xi^5}$.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nn = 8\n\nroots = [np.exp(2j * np.pi * k / n) for k in range(n) if np.gcd(k, n) == 1]\n\nreal_parts = [root.real for root in roots]\nimaginary_parts = [root.imag for root in roots]\n\nlabels = ['ξ^1', 'ξ^3', 'ξ^5', 'ξ^7']\n\nfor i, (x, y) in enumerate(zip(real_parts, imaginary_parts)):\n    plt.scatter(x, y, color='red', label=labels[i])\n    plt.text(x + 0.1, y, labels[i], fontsize=12)\n\nfor root in roots:\n    plt.plot([0, root.real], [0, root.imag], linestyle='--', color='blue')\n\nplt.xlabel('Real Part')\nplt.ylabel('Imaginary Part')\nplt.axhline(0, color='black', linewidth=0.5)\nplt.axvline(0, color='black', linewidth=0.5)\nplt.grid(color='gray', linestyle='--', linewidth=0.5)\n\nplt.axis('equal')\n\nplt.xlim(-1.5, 1.5)\nplt.ylim(-1.5, 1.5)\n\nplt.title(f'Primitive 8th Roots of Unity')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-3-output-1.png){width=619 height=449}\n:::\n:::\n\n\nThis makes intuitive sense if we look at a graph of the roots and see that primitive roots of unity are always symmetric over the x axis.\n\n$\\mathbb{H}$ of is a subring of $\\mathbb{C}^N$ that contains elements of $\\mathbb{C}^N$ where the conjugate is also in the subring.\n\nWe define an operation $\\pi^{-1}$ which expands a vector $\\mathbb{C}^{N/2}$ into $\\mathbb{H}$\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndef pi_inverse(z: np.ndarray) -> np.ndarray:\n    return np.concatenate([z, [np.conjugate(x) for x in z[::-1]]])\n\nz = np.array([3+4j,2-1j])\n\nfor i in range(len(z)):\n    print(f\"i: {i}, {z[i]} = i: {(-i-1) % 4}, {np.conjugate(z[-i])}\")\n\nprint()\nprint(list(pi_inverse(z)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ni: 0, (3+4j) = i: 3, (3-4j)\ni: 1, (2-1j) = i: 2, (2+1j)\n\n[(3+4j), (2-1j), (2+1j), (3-4j)]\n```\n:::\n:::\n\n\n$\\sigma(x)$ is equivalent to the evaluation of a polynomial on the roots of unity\nfor the given cyclotomic polynomial which will produce an element in $\\mathbb{C}^N$. \n\nImagine $\\Delta$ is 10,000. We can say that $\\frac{(\\Delta m * \\Delta n)}{\\Delta^2} =  m * n$. \nFor example let $m = 3.14$ and $n = 2.72$. We expect the result to equal 8.5408.\n\n1. Multiply $m$ by $\\Delta$, $\\Delta * m = 31,400$\n2. Multiply $n$ by $\\Delta$, $\\Delta * n = 27,200$\n3. Add $\\Delta m * \\Delta n = 854,080,000$\n4. Divide result by $\\Delta^2$, $854,080,000 / \\Delta^2 = 8.5408$\n\nThe canonical embedding $\\sigma$ is defined as $\\sigma : \\mathbb{R}[X]/(X^N +1) \\rightarrow \\mathbb{C}^N$ which is equaluating the polynomial on\nthe primitive complex roots of unity to get a vector of points\nIts inverse would be $\\sigma^{-1} : \\mathbb{C}^N \\rightarrow \\mathbb{R}[X]/(X^N +1)$ which takes a list of points and produces a polynomial.\n\nAn element in $\\mathbb{H}$ is not necessarily an element in $\\sigma(\\mathcal{R})$ so we have to project each element into $\\sigma(\\mathcal{R})$.\n\nWe want to project the elements of $\\mathbb{H}$ onto the bases of $\\sigma(\\mathcal{R})$ which are $\\beta = (\\sigma(1),\\sigma(X),\\dots,\\sigma(X^{N−1}))$ and to have integer coefficients rather than complex ones.\n\nA technique for this discretization is called \"coordinate-wise randomized rounding\" and is explained in section 2.4.2 of [A Toolkit for Ring-LWE Cryptography](https://web.eecs.umich.edu/~cpeikert/pubs/toolkit.pdf).\n\nThe first step is to project the elements of our vector $z$ onto the bases of $\\sigma(\\mathcal{R})$.\n\nThis can be done by using the vector projection equation first learning in a college algebra course.\nIt is defined as $proj_\\beta z = \\frac{z * \\beta}{\\left\\| \\beta \\right\\|} * \\beta$.\n\nAfter that we will have a polynomial that has the same bases of $\\sigma(\\mathcal{R})$, but we still need to round it so that it has integer coefficients.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndef rand_round(x: float) -> int:\n    decimal = x - np.floor(x)\n    f = np.random.choice([decimal-1, decimal])\n    return int(x + f)\n\n\ndef cwrr(coords: np.ndarray) -> np.ndarray:\n    out = []\n\n    for coord in coords:\n        real = coord.real\n        imag = coord.imag\n        \n        real_round = rand_round(real)\n        imag_round = rand_round(imag)\n\n        out.append(real_round + imag_round * 1j)\n\n    return np.array(out)\n\n\ndef discretization(z: np.ndarray):\n    bases = np.vander(primitive_nth_roots_of_unity(2*N), N, increasing=True).T\n    proj = np.array([np.vdot(z, b) / np.vdot(b,b) for b in bases])\n\n    return bases.T @ cwrr(proj)\n```\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nfrom numpy.polynomial import Polynomial\n\n\nDELTA = 64\nN = 4\n\n\ndef pi_inverse(z: np.ndarray) -> np.ndarray:\n    return np.concatenate([z, [np.conjugate(x) for x in z[::-1]]])\n\n\ndef rand_round(x: float) -> int:\n    decimal = x - np.floor(x)\n    f = np.random.choice([decimal-1, decimal])\n    return int(x + f)\n\n\ndef cwrr(coords: np.ndarray) -> np.ndarray:\n    out = []\n\n    for coord in coords:\n        real = coord.real\n        imag = coord.imag\n        \n        real_round = rand_round(real)\n        imag_round = rand_round(imag)\n\n        out.append(real_round + imag_round * 1j)\n\n    return np.array(out)\n\n\ndef discretization(z: np.ndarray):\n    bases = np.vander(primitive_nth_roots_of_unity(2*N), N, increasing=True).T\n    proj = np.array([np.vdot(z, b) / np.vdot(b,b) for b in bases])\n\n    return bases @ cwrr(proj)\n\n\ndef sigma_inverse(b: np.ndarray) -> Polynomial:\n    A = np.vander(primitive_nth_roots_of_unity(2*N), N, increasing=True)\n    coeffs = np.linalg.solve(A, b)\n    return Polynomial(coeffs)\n\n\ndef encode(z: np.ndarray) -> Polynomial:\n    out = pi_inverse(z)\n    out *= DELTA\n    out = discretization(out)\n    out = sigma_inverse(out)\n    \n    out = np.round(np.real(out.coef)).astype(int)\n    return Polynomial(out)\n\n\nz = np.array([3+4j, 2-1j])\nencoded_z = encode(z)\nprint(encoded_z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n114.0 + 58.0·x + 30.0·x² - 124.0·x³\n```\n:::\n:::\n\n\n## Decoding\n\n## Encryption\n\n## Decryption\n\n## Addition of Constants\n\n## Addition of Ciphertexts\n\n## Multiplication of Constants\n\n## Multiplication of Ciphertexts\n\n## Next Steps\n\n## References\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}