{
  "hash": "b9e56d8c4bebf312efb55ac555227e76",
  "result": {
    "markdown": "---\ntitle: \"Introduction to CKKS\"\nauthor: \"Trevor Tomlin\"\ndate: \"2023-09-14\"\ncategories: [cryptography]\n---\n\n# An introduction to the **HEAAN / CKKS** homomorphic encryption scheme\nThe **HEAAN / CKKS** scheme introduced in the paper, *Homomorphic Encryption\nfor Arithmetic of Approximate Numbers* or named after the authors, Jung Hee Cheon, Andrey Kim, Miran Kim, and Yongsoo Song is a leveled\nhomomorphic scheme based upon the Ring Learning with Errors (RLWE) problem that allows encypted computation on real real numbers. This scheme differs from\nBGV/BFV schemes because it works on real numbers rather than integers.\n\n## Notation\nUnderstanding the following notations will be helpful for reading this blog post:\n\n* $\\mathcal{R} = \\mathbb{Z}[X]/(X^N +1)$\n* $\\mathbb{Z}_q$ is in the range $(−q/2, q/2]$\n* $\\lfloor x \\rceil$ represents the rounding of the real number x to the closest integer\n\n## Parameters\n\n$\\Delta$ is the scaling factor\n\n## Encoding \nThis scheme operates allows us to encode a vector, $\\mathbb{C}^{N/2}$, into the ciphertext space, $\\mathcal{R}_q = (\\mathbb{Z}/q\\mathbb{Z})[X]/(X^N +1)$ \nusing a ring isomorphism and cannoncial embedding map. \n\nA cyclotomic polynomial is a polynomial with integer coefficients whose roots are all\nprimitive. An example would be the 4th cyclotomic polynomial or $\\phi_4(x) = x^2 + 1$.\nOne important property of cyclotomic polynomials is that if N is a power of two, then\nthe polynomial is equal to $x^{N/2} + 1$. \n\n<!-- ADD MORE ABOUT WHY POWERS OF 2 ARE GOOD -->\n[A Toolkit for Ring-LWE Cryptography](https://web.eecs.umich.edu/~cpeikert/pubs/toolkit.pdf)\n\nMore information about these polynomials can be \nfound here on [Wikipedia](https://en.wikipedia.org/wiki/Cyclotomic_polynomial)\n\nFor any cyclotomic polynomial, $a$, we can say that $a(\\xi^j) = a(\\overline{\\xi^{-j}})$ \n\n::: {.cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport math\n\ndef primitive_nth_roots_of_unity(n: int) -> np.ndarray:\n    roots = []\n    \n    for i in range(1, n+1):\n        if math.gcd(i, n) == 1:\n            root = np.e ** (2 * np.pi * 1j * i / n)\n            roots.append(root)\n\n    return np.array(roots)\n\neigth_prim_roots = primitive_nth_roots_of_unity(8)\n\nfor i, r in enumerate(eigth_prim_roots):\n    print(f\"Root #{i+1}: {r}\\nConjugate: {np.conjugate(r)}\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRoot #1: (0.7071067811865476+0.7071067811865475j)\nConjugate: (0.7071067811865476-0.7071067811865475j)\n\nRoot #2: (-0.7071067811865475+0.7071067811865476j)\nConjugate: (-0.7071067811865475-0.7071067811865476j)\n\nRoot #3: (-0.7071067811865477-0.7071067811865475j)\nConjugate: (-0.7071067811865477+0.7071067811865475j)\n\nRoot #4: (0.7071067811865474-0.7071067811865477j)\nConjugate: (0.7071067811865474+0.7071067811865477j)\n\n```\n:::\n:::\n\n\nFrom this week can see that $\\xi^1 = \\overline{\\xi^7}$ and $\\xi^3 = \\overline{\\xi^5}$.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nn = 8\n\nroots = [np.exp(2j * np.pi * k / n) for k in range(n) if np.gcd(k, n) == 1]\n\nreal_parts = [root.real for root in roots]\nimaginary_parts = [root.imag for root in roots]\n\nlabels = ['ξ^1', 'ξ^3', 'ξ^5', 'ξ^7']\n\nfor i, (x, y) in enumerate(zip(real_parts, imaginary_parts)):\n    plt.scatter(x, y, color='red', label=labels[i])\n    plt.text(x + 0.1, y, labels[i], fontsize=12)\n\nfor root in roots:\n    plt.plot([0, root.real], [0, root.imag], linestyle='--', color='blue')\n\nplt.xlabel('Real Part')\nplt.ylabel('Imaginary Part')\nplt.axhline(0, color='black', linewidth=0.5)\nplt.axvline(0, color='black', linewidth=0.5)\nplt.grid(color='gray', linestyle='--', linewidth=0.5)\n\nplt.axis('equal')\n\nplt.xlim(-1.5, 1.5)\nplt.ylim(-1.5, 1.5)\n\nplt.title(f'Primitive 8th Roots of Unity')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-3-output-1.png){width=619 height=449}\n:::\n:::\n\n\nThis makes intuitive sense if we look at a graph of the roots and see that primitive roots of unity are always symmetric over the x axis.\n\n$\\mathbb{H}$ of is a subring of $\\mathbb{C}^N$ that contains elements of $\\mathbb{C}^N$ where the conjugate is also in the subring.\n\nWe define an operation $\\pi^{-1}$ which expands a vector $\\mathbb{C}^{N/2}$ into $\\mathbb{H}$\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndef pi_inverse(z: np.ndarray) -> np.ndarray:\n    return np.concatenate([z, [np.conjugate(x) for x in z[::-1]]])\n\nz = np.array([3+4j,2-1j])\n\nfor i in range(len(z)):\n    print(f\"i: {i}, {z[i]} = i: {(-i-1) % 4}, {np.conjugate(z[-i])}\")\n\nprint()\nprint(list(pi_inverse(z)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ni: 0, (3+4j) = i: 3, (3-4j)\ni: 1, (2-1j) = i: 2, (2+1j)\n\n[(3+4j), (2-1j), (2+1j), (3-4j)]\n```\n:::\n:::\n\n\n$\\sigma(x)$ is equivalent to the evaluation of a polynomial on the roots of unity\nfor the given cyclotomic polynomial which will produce an element in $\\mathbb{C}^N$. \n\nImagine $\\Delta$ is 10,000. We can say that $\\frac{(\\Delta * m + \\Delta * n)}{\\Delta} =  m + n$. For example let $m = 3.14$ and $n = 2.72$. We expect the result to equal 5.86.\n\n1. Multiply $m$ by $\\Delta$, $\\Delta * m = 31,400$\n2. Multiply $n$ by $\\Delta$, $\\Delta * n = 27,200$\n3. Add $\\Delta m + \\Delta n = 58,600$\n4. Divide result by $\\Delta$, $58,600 / \\Delta = 5.86$\n\n## Decoding\n\n## Encryption\n\n## Decryption\n\n## Addition of Constants\n\n## Addition of Ciphertexts\n\n## Multiplication of Constants\n\n## Multiplication of Ciphertexts\n\n## Next Steps\n\n## Resources\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}