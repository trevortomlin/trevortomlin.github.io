{
  "hash": "320f67a39dae0bec024659fd2f3160a7",
  "result": {
    "markdown": "---\ntitle: \"Learning With Errors\"\nauthor: \"Trevor Tomlin\"\ndate: \"2023-06-16\"\ncategories: [cryptography]\n---\n\n# Learning With Errors (LWE) Problem in Cryptography\n\nThe **Learning With Errors (LWE)** problem is a mathematical problem that plays a significant role in modern cryptographic schemes. It is based on the concept of finding a solution to a system of linear equations with errors. Let's explore the LWE problem and its applications in cryptography.\nProblem Statement\n\nThis problem is incredibly similar to the shortest vector problem (SVP) and the closest vector problem (CVP). I suggest you read that article first if you haven't already.\n\n## Example: Encryption using Learning With Errors\n\nThe LWE problem can be formulated as the equation $Aâ‹…s+e=b\\mod{p}$, where:\n\n- $A$ is the public key matrix,\n- $s$ is the secret vector,\n- $e$ is the noise vector,\n- $b$ is the resulting ciphertext vector, and\n- $p$ is a modulus.\n\nLet's walk through a concrete example to illustrate how the Learning With Errors (LWE) problem can be used for encryption. We will use small values to demonstrate the process.\n\nSuppose we have the following parameters:\n\n- Public Key Matrix $A = \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix}$\n- Modulus $p = 7$\n- Secret Vector $s = \\begin{pmatrix} 3 \\\\ 1 \\end{pmatrix}$\n- Noise Vector $e = \\begin{pmatrix} 5 \\\\ 6 \\end{pmatrix}$\n\n::: {.cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\"}\nfrom IPython.display import display, Math, Latex\nimport numpy as np\n\n# From KMChris\n# https://gist.github.com/KMChris/8fd878826453c3d55814b3293c7b084c\ndef print_matrix(array):\n    matrix = ''\n    for row in array:\n        try:\n            for number in row:\n                matrix += f'{number}&'\n        except TypeError:\n            matrix += f'{row}&'\n        matrix = matrix[:-1] + r'\\\\'\n    return r'\\begin{bmatrix}'+matrix+r'\\end{bmatrix}'\n\nq = 7\nA=np.array([[1 ,2],[3, 4]])\nsA = np.array([[5],[9]])\neA = np.array([[2],[-1]])\nbA = np.matmul(A,sA)%q\nbA = np.add(bA,eA)%q\n\nmatrix = r\"b = \" + print_matrix(A)\nmatrix += r\" * \" + print_matrix(sA)\nmatrix += r\" + \" + print_matrix(eA)\nmatrix += r\" \\mod{\" + str(q) + r\"}\"\nmatrix += r\" = \" + print_matrix(bA)\n\nmatrix = Math(matrix)\n\ndisplay(matrix)\n```\n\n::: {#matrix-example .cell-output .cell-output-display}\n$\\displaystyle b = \\begin{bmatrix}1&2\\\\3&4\\\\\\end{bmatrix} * \\begin{bmatrix}5\\\\9\\\\\\end{bmatrix} + \\begin{bmatrix}2\\\\-1\\\\\\end{bmatrix} \\mod{7} = \\begin{bmatrix}4\\\\1\\\\\\end{bmatrix}$\n\nAn example of encryption using LWE\n:::\n:::\n\n\nTo encrypt the message of length $n$ represented in binary (which has t number of different values), we sample $n$ rows from $A$ and the corresponding values from $b$. We add up all the rows into a single equation and we add $\\lfloor\\frac{q}{t}\\rfloor$ to $b$.\n\nIn this case we will only use a single row, but the same process still applies.\n\n- $[1 \\quad 2] = 4$\n\nIf our message is the bit 1, we add $\\lfloor\\frac{q}{2}\\rfloor$ to $b$:\n\n- $[1 \\quad 2] = 4 + \\lfloor\\frac{q}{2}\\rfloor = 7$\n\nIf our message is the big 0, we add $0$ to $b$:\n\n- $[1 \\quad 2] = 4$\n\nNext, the person with the secret key multiplies the ciphertext vector $b$ by the secret vector $s$ and takes the result modulo $p$ to obtain the original message. There is a small error, but this is removed by rounding the result to the nearest value representing a bit. In our case it is rounded to either 0 representing 0 or 7 representing 1.\n\n::: {#decryption-example .cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\nprint(\"A_rows * sA % q = correct\")\nprint(\"b_row - correct = encoded\")\n\n# Encoded 1 bit\nA_row = np.array([1, 2])\nb_row = 7\n\ncorrect = np.matmul(A_row,sA)%q\n\nencoded = b_row - correct\n\nprint(f\"1 bit which should be very close to 7: {encoded}\")\n\n# Encoded 0 bit\nA_row = np.array([1, 2])\nb_row = 4\n\ncorrect = np.matmul(A_row,sA)%q\n\nencoded = b_row - correct\nprint(f\"0 bit which should be very close to 0: {encoded}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA_rows * sA % q = correct\nb_row - correct = encoded\n1 bit which should be very close to 7: [5]\n0 bit which should be very close to 0: [2]\n```\n:::\n:::\n\n\n## Usage in Cryptography\n\nFully Homomorphic Encryption (FHE) is a revolutionary cryptographic scheme that allows computations to be performed directly on encrypted data, without the need for decryption. FHE based on LWE enables secure computation on sensitive data while preserving privacy. It allows for powerful operations like addition and multiplication to be performed on encrypted data, providing a practical solution for secure computation in various applications, such as privacy-preserving data analysis and secure outsourcing of computations.\n\nKyber is a post-quantum secure key encapsulation mechanism (KEM) based on LWE. It is designed to provide secure key exchange in the presence of powerful quantum computers. Kyber uses the LWE problem to generate cryptographic keys, ensuring that the exchanged keys remain secure even if an adversary has access to quantum computing resources. Kyber is a promising candidate for secure communication in a post-quantum world, offering strong security guarantees and efficient performance.\n\nBoth TFHE (The Fully Homomorphic Encryption Library) and Kyber highlight the practical applications of the LWE problem in constructing advanced cryptographic algorithms. By leveraging the mathematical hardness of the LWE problem, these algorithms provide secure and efficient solutions for various cryptographic tasks, contributing to the development of post-quantum secure systems.\n\n## Other Problems\nThe Learning With Errors (LWE) problem is closely related to other lattice-based problems, including Ring Learning With Errors (RLWE) and General Learning With Errors (GLWE). These problems share similar mathematical structures and serve as the foundation for various cryptographic schemes.\n\nRLWE extends the LWE problem by introducing an additional algebraic structure called a ring. It involves working with polynomials instead of vectors, which offers certain advantages in cryptographic constructions. RLWE allows for the development of efficient encryption schemes, such as the NTRUEncrypt scheme, which provides post-quantum security.\n\nGLWE generalizes the LWE problem by considering a more general form of noise distribution. It allows for more flexibility in the noise generation process and offers enhanced security guarantees. GLWE is utilized in cryptographic constructions such as functional encryption and obfuscation, enabling advanced functionalities like fine-grained access control and program obfuscation.\n\n## Conclusion\n\nIn conclusion, the Learning With Errors (LWE) problem is a powerful mathematical framework that has gained significant attention in the field of post-quantum cryptography. Its security is based on the presumed hardness of finding the secret key from the public key, even when given noisy and seemingly random equations. The LWE problem offers a promising approach to building cryptographic schemes that are resilient against attacks from both classical and quantum computers. As researchers continue to explore and develop new algorithms and techniques in this area, the LWE problem holds great potential for providing secure communication and protecting sensitive information in the era of quantum computing.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}