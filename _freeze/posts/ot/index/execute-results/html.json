{
  "hash": "f531495461124e1494b87d898da6800b",
  "result": {
    "markdown": "---\ntitle: \"Oblivious Transfer\"\nauthor: \"Trevor Tomlin\"\ndate: \"2023-06-26\"\ncategories: [cryptography]\n---\n\n![Diagram explaining oblivious transfer](diagram1.png)\n\n# Oblivious Transfer\n**Oblivious Transfer** (OT) is a cryptographic protocol that allows one party, often referred to as the sender, to send a set of private messages to another party, known as the receiver, without the sender learning which message was received by the receiver and without the receiver learning any messages other than the one they chose.\n\n## Rabin's Oblivious Transfer\nIn 1981, Michael Rabin published a paper titled \"How to Exchange Secrets with Oblivious Transfer\" in which he described a protocol for 1-out-of-2 oblivious transfer. It is based on the RSA cryptosystem and relies on the difficulty of factoring large integers. There is a 50% chance that the receiver will receive the first message and a 50% chance that the receiver will receive the second message. The sender does not know which message the receiver received and the receiver does not know the contents of the message they did not receive.\n\n## 1-out-of-2 oblivious transfer\n1-out-of-2 oblivious transfer is a more useful form of oblivious transfer than Rabin's original protocol. It allows the sender to send two messages to the receiver and the receiver to choose which message they receive. The sender does not know which message the receiver received and the receiver does not know the contents of the message they did not receive. It can be generalized to n-out-of-m oblivious transfer, where the sender sends m messages to the receiver and the receiver chooses one of the messages to receive. This is the basis for many protocols underlying secure multiparty computation.\n\nBelow explains the steps for 1-out-of-2 oblivious transfer:\n\n1. Bob and Alice agree on a generator $g$ and prime number $p$\n2. Alice generates a random number $a$ and sends $g^a$ to Bob\n3. Bob generates a random number $b$ and sends $B=g^b$ if he wants the 0th message and $B=Ag^b$ if he wants the 1st message\n4. Alice computer $k_0 = Hash(B^a)$ and $k_1 = Hash((B/A)^a)$ and sends $E_{k_0}(m_0)$ and $E_{k_1}(m_1)$ to Bob\n5. Bob calculates k_r = Hash((A)^b) and decrypts both messages to get $m_r$\n\nHere is the protocol implemented in Python where Bob wants the 0th message:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport random\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.Padding import pad, unpad\nimport struct\nimport hashlib\n\n# Hashes data using SHA3-256\ndef sha3_256_hash(data):\n    sha3_hash = hashlib.sha3_256()\n\n    if not isinstance(data, bytes):\n        data = str(data).encode()\n\n    sha3_hash.update(data)\n\n    hash_result = sha3_hash.digest()\n\n    return hash_result\n\n# Establish shared parameters\ng = 3\np = 17\n\n# Alice generates a random number a and sends g^a to Bob\n# ! This is not secure, but it is just for demonstration purposes !\na = random.randint(0, p)\nA = (g ** a) % p\n\n# Bob generates a random number b and sends B=g^b to Alice\n# Bob wants the 0th message\n# Bob could also send B=Ag^b if he wanted the 1st message\n# ! This is not secure, but it is just for demonstration purposes !\nb = random.randint(0, p)\nB = (g ** b) % p\nkr = sha3_256_hash((A ** b) % p)\n\n# Alice computes k0 = Hash(B^a) and k1 = Hash((B/A)^a) and sends E_{k0}(m0) and E_{k1}(m1) to Bob\nk0 = sha3_256_hash((B ** a) % p)\nk1 = sha3_256_hash(((B / A) ** a) % p)\n\nm0 = pad(b\"Hello\", 16)\nm1 = pad(b\"World\", 16)\n\n# ! This is not secure, but it is just for demonstration purposes !\ncipher0 = AES.new(k0, AES.MODE_ECB)\nc0 = cipher0.encrypt(m0)\n\ncipher1 = AES.new(k1, AES.MODE_ECB)\nc1 = cipher1.encrypt(m1)\n\n# Bob calculates kr = Hash((A)^b) and decrypts both messages to get mr\n# ! This is not secure, but it is just for demonstration purposes !\ncipherb = AES.new(kr, AES.MODE_ECB)\n\nprint(unpad(cipherb.decrypt(c0), 16))\n\ntry:\n    print(\"C0: \" + unpad(cipherb.decrypt(c1), 16))\nexcept ValueError:\n    print(\"Bob did not receive the 1st message\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nb'Hello'\nBob did not receive the 1st message\n```\n:::\n:::\n\n\n## 1-out-of-n oblivious transfer\nThe protocol shown above can also be generalized to support more than 2 messages by the sender having $n$ messages and the reciever having index $i$ which represents the message they want from the sender. \n\nThere are also ways to make it $k$ of $n$ where a reciever can request $k$ messages from the sender. \n\n## Applications\n- Secure Multiparty Computation (MPC):\n\n    - Oblivious Transfer is a fundamental component of secure MPC protocols.\n    It allows multiple parties to jointly compute functions on private inputs without revealing individual inputs.\n    Enables privacy-preserving computations in scenarios such as private auctions and collaborative machine learning.\n\n- Private Information Retrieval (PIR):\n\n    - PIR enables retrieving specific information from a database without revealing the queried item or learning about other items.\n    Oblivious Transfer is used to construct PIR protocols, preserving user privacy while retrieving desired data.\n\n## Conclusion\nOblivious Transfer is a powerful cryptographic protocol that enables secure communication between parties while preserving privacy. It provides a way for senders to transfer private messages to receivers without either party gaining information about the unselected messages. The applications of oblivious transfer extend to various domains where privacy and secure computations are essential. By leveraging the principles of cryptography and secure protocols, oblivious transfer offers a valuable tool for building secure systems and protecting sensitive information.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}